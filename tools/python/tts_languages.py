#!/usr/bin/env python3

import re
import argparse

LANGUAGES_HPP_TEMPLATE = """\
#pragma once

#include <array>
#include <string>

// This file is autogenerated while exporting sounds.csv from the google table.
// It contains the list of languages which can be used by TTS.
// It shall be included to Android(jni) and iOS part to get the languages list.

namespace routing
{{
namespace turns
{{
namespace sound
{{
std::array<std::string, {lang_list_size}> const kLanguageList =
{{{{
{lang_list}
}}}};
}}  // namespace sound
}}  // namespace turns
}}  // namespace routing
"""

def parse_args():
    parser = argparse.ArgumentParser(
        description="Creates a language.hpp out of the sound.txt file.",
        usage="%(prog)s <path_to_sound.txt> <path_to_languages.hpp>"
    )
    parser.add_argument('input_file', help="Path to the sound.txt file")
    parser.add_argument('output_file', help="Path to the output languages.hpp file")
    return parser.parse_args()

def read_languages(strings_name):
    langs = set()
    RE_LANG = re.compile(r'^\s*([\w-]+)\s*=')
    with open(strings_name, "r") as langs_file:
        for line in langs_file:
            m = RE_LANG.search(line)
            if m:
                langs.add(m.group(1))
    return langs

def make_languages_hpp(langs, hpp_name):
    print(f"Creating {hpp_name}")
    lang_str = ",\n".join([f'  "{language}"' for language in sorted(langs)])
    with open(hpp_name, "w") as hpp_file:
        hpp_file.write(LANGUAGES_HPP_TEMPLATE.format(lang_list_size=len(langs), lang_list=lang_str))

def run():
    args = parse_args()
    langs = read_languages(args.input_file)
    make_languages_hpp(langs, args.output_file)

if __name__ == "__main__":
    run()
